# [蓝桥杯 2023 省 B] 飞机降落

## 题目描述

$N$ 架飞机准备降落到某个只有一条跑道的机场。其中第 $i$ 架飞机在 $T_{i}$ 时刻到达机场上空，到达时它的剩余油料还可以继续盘旋 $D_{i}$ 个单位时间，即它最早可以于 $T_{i}$ 时刻开始降落，最晩可以于 $T_{i}+D_{i}$ 时刻开始降落。降落过程需要 $L_{i}$ 个单位时间。

一架飞机降落完毕时，另一架飞机可以立即在同一时刻开始降落，但是不能在前一架飞机完成降落前开始降落。

请你判断 $N$ 架飞机是否可以全部安全降落。

## 输入格式

输入包含多组数据。

第一行包含一个整数 $T$，代表测试数据的组数。

对于每组数据，第一行包含一个整数 $N$。

以下 $N$ 行，每行包含三个整数 $T_{i},D_{i},L_{i}$。

## 输出格式

对于每组数据，输出 `YES` 或者 `NO`，代表是否可以全部安全降落。

## 样例 #1

### 样例输入 #1

```
2
3
0 100 10
10 10 10
0 2 20
3
0 10 20
10 10 20
20 10 20
```

### 样例输出 #1

```
YES
NO
```


### 我的思路
&emsp; 最开始我是准备用排序做的，也就是依照每个飞机的**最迟准备降落时间t + d**进行排序，因为这个时间越小就意味着这个飞机得先降落，不然这个飞机肯定会坠毁，但是这样写来肯定不行，没有合理的排序逻辑。
&emsp; 紧接着就想到**暴力搜索DFS**，通过依次让每个飞机优先降落，枚举每一种可能性，只要有一个存在就可以，必要时还可以剪枝：在DFS中，我们传了一个参数now表示现在的时间，这个now取决于**上一个飞机的降落时间**，如果目前的飞机的到达时间+盘旋时间小于这个now，说明这个飞机肯定是无法在上一个飞机降落完成后再降落的，直接跳过即可。当目前的已降落飞机数量i == 总飞机数n，说明全部降落，找到答案，返回True
### 我的代码
```python
k = int(input())

def dfs_search(i, now):
    if i == n:
        return True
    for j in range(n):
        if vis[j] or plane[j][0] + plane[j][1] < now:  # 不能降落
            continue
        vis[j] = 1
        if dfs_search(i + 1, max(now, plane[j][0]) + plane[j][2]):
            return True
        vis[j] = 0
    return False


while k > 0:
    n = int(input())
    plane = []
    for _ in range(n):
        t, d, l = map(int, input().strip().split())
        plane.append((t, d, l))
        # ((最早降落时间， 最迟降落时间), (最早完成降落时间， 最迟完成降落时间))
    vis = [0] * n
    flag = dfs_search(0, 0)
    if flag:
        print("YES")
    else:
        print("NO")
    k -= 1


```